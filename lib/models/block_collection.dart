import 'package:isar/isar.dart';
import 'package:memoweave/models/style_node.dart';

part 'block_collection.g.dart';

/// Styles that affect the whole block.
enum BlockStyle {
  none,
  heading1,
  heading2,
  heading3,
  heading4,
  heading5,
  heading6,
}

/// Collection definition for a text block.
@collection
class BlockCollection {
  /// Unique identifier for this block.
  ///
  /// Will be assigned by the database system if null.
  Id? id;

  /// Block content.
  final String text;

  /// Block base style.
  ///
  /// Applies to the whole block in addition to any [InlineStyle] objects.
  @enumerated
  final BlockStyle blockStyle;

  /// Inline styles to apply onto the text.
  ///
  /// Requirement: nodes do not overlap their responsible regions,
  /// nodes are stored in ascending index order,
  /// and the responsible regions are within the text length.
  final List<StyleNode> inlineStyles;

  /// Ordered set of hierarchical children to this block.
  final IsarLinks<BlockCollection> children;

  /// Links pointing back to parent blocks.
  ///
  /// Automatically generated by the database system.
  @Backlink(to: 'children')
  final parents = IsarLinks<BlockCollection>();

  /// Default constructor.
  ///
  /// Defines [id], [text], [blockStyle], [inlineStyles], and [children].
  /// Will supply default values if none are given.
  /// Throws [FormatException] on invalid input.
  BlockCollection({
    this.id,
    this.text = 'Blank state text',
    this.blockStyle = BlockStyle.none,
    this.inlineStyles = const [],
    IsarLinks<BlockCollection>? inChildren,
  }) : children = inChildren ?? IsarLinks<BlockCollection>() {
    // Verify inlineStyles.
    for (var i = 0; i < inlineStyles.length - 1; ++i) {
      // Is not overlapping next style.
      if (inlineStyles[i].isOverlappingWith(inlineStyles[i + 1])) {
        throw const FormatException('Invalid BlockCollection inlineStyle: '
            'styles must not have overlapping bounds.');
      }

      // Style's responsible regions are in non-descending order.
      if (inlineStyles[i] > inlineStyles[i + 1]) {
        throw const FormatException('Invalid BlockCollection inlineStyles: '
            'must be defined in ascending index order.');
      }
    }

    // Verify last inline style is within text's bounds.
    // Unnecessary to test for < 0 index since this is already
    // tested in the style node.
    if (inlineStyles.isNotEmpty && inlineStyles.last.endIndex > text.length) {
      throw const FormatException('Invalid BlockCollection inlineStyles: '
          'must not define style out of text bounds.');
    }
  }

  /// Copy builder.
  ///
  /// Creates a copy of the current Block and updates the fields to
  /// [id], [text], [blockStyle], and [inlineStyles] when provided.
  BlockCollection copyWith({
    Id? id,
    String? text,
    BlockStyle? blockStyle,
    List<StyleNode>? inlineStyles,
    IsarLinks<BlockCollection>? children,
  }) {
    return BlockCollection(
      id: id ?? this.id,
      text: text ?? this.text,
      blockStyle: blockStyle ?? this.blockStyle,
      inlineStyles: inlineStyles ?? this.inlineStyles,
      inChildren: children ?? this.children,
    );
  }
}
